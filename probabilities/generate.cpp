#include <TROOT.h>
#include <TH2F.h>
#include <TFile.h>
#include <cmath>
#include <TCanvas.h>

double muon_flux(double E, double theta){
  const double p1 = 0.102573;
  const double p2 = -0.068287;
  const double p3 = 0.958633;
  const double p4 = 0.0407253;
  const double p5 = 0.817285;

  double costheta_star = sqrt((cos(theta)*cos(theta) + pow(p1,2) + p2*pow(cos(theta),p3) + p4*pow(cos(theta),p5))/(1 + p1*p1 + p2 + p4));

  return 0.14*pow(E*(1 + 3.64/(E*pow(costheta_star,1.29))),-2.7)*(1/(1 + (1.1*E*costheta_star)/115) + 0.054/(1 + (1.1*E*costheta_star)/850));
}

void generate() {
  // Number of muons passing through the RPC detector generated by the Modified Gaisser Formula

  // Create a 2D histogram with x and y range
    const int x_bins = 100; // Number of bins for x-axis
    const int y_bins = 100; // Number of bins for y-axis
    const double area = 600*300;   // RPC plate size in cm^2
    const double time = 1.0;      // time elapsed
    const double E_low = 0.01;
    const double E_high = 10.0;
    const double theta_low = 0.0;
    const double theta_high = 90.0;

    double range_E     = (E_high - E_low)/x_bins;
    double range_theta = (theta_high - theta_low)/y_bins;
    
    TH2F* hist = new TH2F("muon_flux", "2D Histogram of Modified Gaisser Formula", x_bins, E_low, E_high, y_bins, theta_low, theta_high);

    // Loop over the bins and fill the histogram with sin(x, y) values
    for (int ix = 1; ix <= x_bins; ix++) {
        for (int iy = 1; iy <= y_bins; iy++) {
            // Calculate the x and y values for the bin centers
            double x = hist->GetXaxis()->GetBinCenter(ix);
            double y = hist->GetYaxis()->GetBinCenter(iy);
            
            double y_up = hist->GetYaxis()->GetBinUpEdge(iy);
            double y_down = hist->GetYaxis()->GetBinLowEdge(iy);

            // Calculate and fill the histogram
            double value = muon_flux(x,y*acos(-1)/180)*area*time*range_E*abs(cos(y_down*acos(-1)/180) - cos(y_up*acos(-1)/180));
            
            //double value = muon_flux(x,y*acos(-1)/180)*area*time*range_E;
            hist->SetBinContent(ix, iy, value);
        }
    }

    // Create and open a ROOT file to save the histogram

    TFile *file = new TFile("frequency.root", "RECREATE");

    // Set axis titles
    hist->GetXaxis()->SetTitle("Muon energy (GeV)");  // Set the x-axis title
    hist->GetYaxis()->SetTitle("Zenith angle (Degree)");  // Set the y-axis title

    // Optionally, display the histogram in a canvas
    TCanvas* c0 = new TCanvas("c0", "muon flux frequency", 800, 600);
    hist->Draw("COLZ");
    c0->SaveAs("frequency.png");  // Save the plot as a PNG
    // Write the histogram to the file
    hist->Write();

    double total = hist->Integral();

    TH2F* hist_normalized = (TH2F*)hist->Clone("probability_mass_function");
    hist_normalized->Reset();  // Clear the contents of the new histogram

    // Step 7: Normalize the original histogram by dividing each bin by the total integral
    for (int ix = 1; ix <= x_bins; ix++) {
        for (int iy = 1; iy <= y_bins; iy++) {
            double value = hist->GetBinContent(ix, iy);
            value /= total;  // Normalize by the total integral

            // Set the normalized value in the new histogram
            hist_normalized->SetBinContent(ix, iy, value);
        }
    }

    hist_normalized->GetXaxis()->SetTitle("Muon energy (GeV)");  // Set the x-axis title
    hist_normalized->GetYaxis()->SetTitle("Zenith angle (Degree)");  // Set the y-axis title
    hist_normalized->SetTitle("Probability Mass Function");

    std::cout << "Integrate along the energy and theta = " << hist_normalized->Integral() << std::endl;
    hist_normalized->Write();
    TCanvas* c1 = new TCanvas("c1", "Probability Mass Function", 800, 600);
    hist_normalized->Draw("COLZ");
    c1->SaveAs("pmf.png");

    // Close the file
    file->Close();

    TFile *file2 = new TFile("N_vs_E_theta_normalized_histograms.root", "RECREATE");

    int bin_theta = hist->GetYaxis()->FindBin(0.0);  // Fix theta = pi/4 for example
    TH1F* hist_N_vs_E = new TH1F("N_vs_E", "N vs E for fixed theta = 0", x_bins, 0.1, 10);
    
    double total_N_vs_E = 0;
    for (int ix = 1; ix <= x_bins; ix++) {
        double E = hist->GetXaxis()->GetBinCenter(ix);
        double N = hist->GetBinContent(ix, bin_theta);  // Extract N for fixed theta
        hist_N_vs_E->SetBinContent(ix, N);  // Set the N value
        total_N_vs_E += N;  // Calculate total sum for normalization
    }

    TCanvas* c2 = new TCanvas("c2", "N_E", 800,600);
    hist_N_vs_E->SetTitle("N vs E for fixed theta = 0");
    hist_N_vs_E->GetXaxis()->SetTitle("Energy (GeV)");
    hist_N_vs_E->GetYaxis()->SetTitle("N");
    hist_N_vs_E->Draw("HIST");
    hist_N_vs_E->Write();
    c2->SaveAs("N_vs_E.png");

    // Normalize the histogram by dividing each bin by the total sum
    for (int ix = 1; ix <= x_bins; ix++) {
        double N = hist_N_vs_E->GetBinContent(ix);
        N /= total_N_vs_E;  // Normalize by the total sum
        hist_N_vs_E->SetBinContent(ix, N);  // Update the normalized value
    }

    TCanvas* c3 = new TCanvas("c3", "N_E_normalized", 800, 600);
    hist_N_vs_E->SetTitle("N vs E for fixed theta = 0");
    hist_N_vs_E->GetXaxis()->SetTitle("Energy (GeV)");
    hist_N_vs_E->GetYaxis()->SetTitle("Normalized N");
    hist_N_vs_E->Draw("HIST");
    hist_N_vs_E->Write();
    c3->SaveAs("N_vs_E_normalized.png");

    // Step 5: Normalize the histogram for N(theta)
    int bin_E = hist->GetXaxis()->FindBin(1);  // Fix E = 2 for example
    TH1F* hist_N_vs_theta = new TH1F("N_vs_theta", "N vs theta for fixed E = 1", y_bins, 0, 90);

    double total_N_vs_theta = 0;
    for (int iy = 1; iy <= y_bins; iy++) {
        double t = hist->GetYaxis()->GetBinCenter(iy);
        double N = hist->GetBinContent(bin_E, iy);  // Extract N for fixed E
        hist_N_vs_theta->SetBinContent(iy, N);  // Set the N value
        total_N_vs_theta += N;  // Calculate total sum for normalization
    }

    TCanvas* c4 = new TCanvas("c4", "N_theta", 800, 600);
    hist_N_vs_theta->SetTitle("N vs E for fixed theta = 0");
    hist_N_vs_theta->GetXaxis()->SetTitle("theta (degree)");
    hist_N_vs_theta->GetYaxis()->SetTitle("N");
    hist_N_vs_theta->Draw("HIST");
    hist_N_vs_theta->Write();
    c4->SaveAs("N_vs_theta.png");

    // Normalize the histogram by dividing each bin by the total sum
    for (int iy = 1; iy <= y_bins; iy++) {
        double N = hist_N_vs_theta->GetBinContent(iy);
        N /= total_N_vs_theta;  // Normalize by the total sum
        hist_N_vs_theta->SetBinContent(iy, N);  // Update the normalized value
    }

    TCanvas* c5 = new TCanvas("c5", "N_theta_normalized", 800, 600);
    hist_N_vs_theta->SetTitle("N vs theta for fixed E = 1");
    hist_N_vs_theta->GetXaxis()->SetTitle("Theta (rad)");
    hist_N_vs_theta->GetYaxis()->SetTitle("Normalized N");
    hist_N_vs_theta->Draw("HIST");
    hist_N_vs_theta->Write();
    c5->SaveAs("N_vs_theta_normalized.png");

    
    // Close the new file
    file2->Close();
}
